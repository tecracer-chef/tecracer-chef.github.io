<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Docker Architecture - Intel? ARM? both? | tecRacer Chef</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://tecracer-chef.github.io/2023/03/docker-architecture-intel-arm-both.html><meta http-equiv=content-language content="en-us"><meta property="og:type" content="website"><meta property="og:site_name" content="tecRacer Chef"><meta property="og:title" content="Docker Architecture - Intel? ARM? both?"><meta property="og:url" content="https://tecracer-chef.github.io/2023/03/docker-architecture-intel-arm-both.html"><meta property="og:image" content="https://tecracer-chef.github.io/images/"><meta name=twitter:title content="tecRacer Chef"><meta name=twitter:url content="https://tecracer-chef.github.io/2023/03/docker-architecture-intel-arm-both.html"><meta name=twitter:image content="https://tecracer-chef.github.io/images/"><meta name=twitter:card content><link rel=alternate href=/blog/feed title="Patrick Schaumburg" type=application/rss+xml><link href=https://tecracer-chef.github.io/css/theme.css rel=stylesheet><script src=https://tecracer-chef.github.io/js/jquery.min.js></script>
<script src=https://tecracer-chef.github.io/js/uikit.min.js></script>
<script src=https://tecracer-chef.github.io/js/fa-all.js></script></head><body><div class="uk-container uk-container-center"><div class=tm-header><div class="tm-toolbar uk-clearfix uk-hidden-small"><div class=uk-float-right><div class=uk-panel><ul class=uk-subnav><li><a href=https://github.com/tecracer-chef class="uk-icon-hover uk-icon-small uk-icon-github" target=_blank></a></li><li><a href=https://twitter.com/tecracer class="uk-icon-hover uk-icon-small uk-icon-twitter" target=_blank></a></li><li><a href=https://www.xing.com/companies/tecracergmbh%26co.kg class="uk-icon-hover uk-icon-small uk-icon-xing" target=_blank></a></li><li><a href=https://www.linkedin.com/company/tecracer-group/ class="uk-icon-hover uk-icon-small uk-icon-linkedin" target=_blank></a></li><li><a href=https://www.facebook.com/tecRacer class="uk-icon-hover uk-icon-small uk-icon-facebook" target=_blank></a></li></ul></div></div></div><nav class=uk-navbar><a class=uk-navbar-brand href=/><img class="tm-logo uk-responsive-height uk-hidden-small" src=https://tecracer-chef.github.io/img/logo/logo-tr.png alt>
<img class="tm-logo-small uk-responsive-height uk-visible-small" src=https://tecracer-chef.github.io/img/logo/logo-tr.png alt></a><div class=uk-hidden-small><ul class=uk-navbar-nav><li><a href=/ title>Blog</a></li><li><a href=/authors title>Authors</a></li><li><a href=/github/github-prs.html title>Pull Requests</a></li></ul></div><div class="uk-navbar-flip uk-visible-small"><a href=#offcanvas class=uk-navbar-toggle data-uk-offcanvas></a></div></nav></div><div id=content><main id=tm-content class=tm-content><article class=uk-article><div class="tm-article-featured-image uk-cover-background" style=background-image:url(img/2023/03/4033984096_architecture_skyline.png)></div><div class="tm-article-content uk-position-relative"><div class="tm-article-date uk-text-center"><span class=tm-article-date-day>16</span>
<span class=tm-article-date-month>Mar</span></div><h1 class=uk-article-title>Docker Architecture - Intel? ARM? both?</h1><p class=uk-article-meta>Written by
<a target=_self title="Thomas Heinen's Author Profile SINGLE.HTML" href=/authors/thomas-heinen data-original-title="Author's Profile">Thomas Heinen</a></p><div class=uk-margin><p>Up to a few years back, writing Dockerfiles was easy. In many cases, it still is - unless you are working with a mixed fleet of Intel and ARM-based processors. Are you familiar with this situation and you do not want to maintain two almost identical Dockerfiles? There is a solution&mldr;</p><h2 id=history-and-motivation>History and Motivation</h2><p>CPU Architectures were mostly homogenous for a while. After Apple <a href=https://en.wikipedia.org/wiki/Mac_transition_to_Intel_processors>switched from its previous PowerPC platform to Intel-based Macs in 2006</a>, the majority of the desktop and servers were running on the familiar &ldquo;x86&rdquo; architecture.</p><p>Recently, this changed - and it keeps changing. We now have the ARM-based M1/M2 processors in modern Apple computers, embedded devices have been running ARM for years and years, and AWS iterates on their ARM processor lineup <a href=https://aws.amazon.com/ec2/graviton/>Graviton</a>, after <a href=https://www.crunchbase.com/acquisition/amazon-acquires-annapurna-labs--34f1f987>acquiring Annapurna Labs in 2015</a>. Currently at &ldquo;Graviton 3&rdquo;, these CPUs offer a lot of computing power for little money. And they are much more energy-efficient, making up a good part of the <a href=https://docs.aws.amazon.com/wellarchitected/latest/framework/welcome.html>Well Architected Framework</a>&rsquo;s Sustainability pillar.</p><p>There is even another architecture on the horizon, namely the <a href=https://en.wikipedia.org/wiki/RISC-V>RISC-V architecture</a>. While also being in the same RISC architecture family as ARM, it does not have licensing issues involved. This means, that any company can use the design and create chipsets to distribute freely.</p><p>This revival of a multi-architecture landscape also creates problems - like the aforementioned platform conflicts on servers or even desktops. With the prevalence of Docker, you now need to cover two (or even more) platforms at the same time. While most Linux distributions will be available for all of them and have identical commands and packages, you will have problems if you rely on standalone programs, especially on GitHub.</p><h2 id=theory>Theory</h2><p>Theoretically, the distinction between these two architectures should be simple. You would expect a command to output the architecture, in a distribution-agnostic way. And then, downloads on GitHub should just have that in their package name for easy access.</p><p>Of course, that&rsquo;s not the case.</p><p>In essence, there are at least two schools of thought</p><ul><li>Intel can be referred to as <code>i386</code> (outdated 32 bit), <code>i686</code>, <code>x86_64</code> or <code>amd64</code></li><li>Graviton/Apple Silicon can be referred to as <code>aarch64</code>, <code>arm</code>, or <code>arm64</code></li></ul><p>And of course, there are all those other architectures from embedded systems (<code>armhf</code>, <code>armel</code>), mainframes (<code>s390), and exotic architectures (</code>powerpc<code>, </code>sparc`).</p><p>Luckily, popular packages seem to fall into two categories:</p><ul><li>they offer downloads with <code>x86_64</code> and <code>aarch64</code> in the package names</li><li>or they offer them as <code>arm64</code> and <code>amd64</code></li></ul><p>A few solutions are mixing both styles. Therefore, we will need to address this (later).</p><h2 id=alternative-1-build-arguments>Alternative 1: Build Arguments</h2><p>Docker offers the possibility to pass in arguments at build time. So you can just assign variables for your architectures and use those in the Dockerfile:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:green;font-weight:700>FROM</span><span style=color:#ba2121> ubuntu:22.04</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:green;font-weight:700>ARG</span> ARCH<span>
</span></span></span><span style=display:flex><span><span></span><span style=color:green;font-weight:700>ARG</span> ARCH_ALT<span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#408080;font-style:italic># ...</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:green;font-weight:700>RUN</span> curl https://packages.chef.io/repos/apt/stable/ubuntu/20.04/inspec_5.21.29-1_<span style=color:#19177c>$ARCH</span>.deb --output /tmp/inspec.deb --silent <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> dpkg --install /tmp/inspec.deb <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> rm /tmp/inspec.deb<span>
</span></span></span></code></pre></div><p>When you now build your Docker image, you will do this via</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build --build-arg <span style=color:#19177c>ARCH</span><span style=color:#666>=</span><span style=color:#ba2121>&#34;amd64&#34;</span> .
</span></span><span style=display:flex><span>docker build --build-arg <span style=color:#19177c>ARCH</span><span style=color:#666>=</span><span style=color:#ba2121>&#34;arm64&#34;</span> .
</span></span></code></pre></div><p>This makes the whole process straightforward in your pipelines and keeps the <code>Dockerfile</code> clean. On the flip side, it will not work in situations where the image is built on-the-fly.</p><h2 id=alternative-2-embedding-commands>Alternative 2: Embedding Commands</h2><p>There are some commands which are commonly used to determine the system architecture:</p><ul><li><code>dpkg --print-architecture</code> will result in the <code>amd64</code>/<code>arm64</code> pair, but is only available on Debian/Ubuntu</li><li><code>uname -m</code> or <code>arch</code> will result in the <code>x86_64</code>/<code>aarch64</code> combination and is distribution-agnostic</li></ul><p>You can either use those in your <code>docker build</code> command like before or embed it in the <code>Dockerfile</code> itself:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:green;font-weight:700>FROM</span><span style=color:#ba2121> ubuntu:22.04</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#408080;font-style:italic># ...</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:green;font-weight:700>RUN</span> curl https://packages.chef.io/repos/apt/stable/ubuntu/20.04/inspec_5.21.29-1_<span style=color:green;font-weight:700>$(</span>dpkg --print-architecture<span style=color:green;font-weight:700>)</span>.deb --output /tmp/inspec.deb --silent <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> dpkg --install /tmp/inspec.deb <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> rm /tmp/inspec.deb<span>
</span></span></span></code></pre></div><p>Unfortunately, this results in higher maintenance effort for your code. Until the time when Docker allows dynamic setting of environment variables, this is probably the best way to create Docker images if your influence on the build process is limited.</p><h2 id=exceptions-from-the-rule>Exceptions from the Rule</h2><p>Some software packages cross their streams, as previously mentioned. In these cases, you will probably need some <code>if</code> clause in that particular <code>RUN</code> statement. Luckily, I have only encountered a handful of these.</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:green;font-weight:700>FROM</span><span style=color:#ba2121> ubuntu:22.04</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#408080;font-style:italic># ...</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:green;font-weight:700>RUN</span> <span style=color:#19177c>ARCH</span><span style=color:#666>=</span><span style=color:green;font-weight:700>$(</span>uname -m<span style=color:green;font-weight:700>)</span> <span style=color:#666>&amp;&amp;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>[</span> <span style=color:#ba2121>&#34;</span><span style=color:#19177c>$ARCH</span><span style=color:#ba2121>&#34;</span> <span style=color:#666>==</span> <span style=color:#ba2121>&#34;aarch64&#34;</span> <span style=color:#666>]</span>; <span style=color:green;font-weight:700>then</span> <span style=color:#19177c>ARCH</span><span style=color:#666>=</span><span style=color:#ba2121>&#34;arm64&#34;</span>; <span style=color:green;font-weight:700>fi</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> curl --location-trusted https://github.com/charmbracelet/glow/releases/download/v1.5.0/glow_1.5.0_linux_<span style=color:#19177c>$ARCH</span>.tar.gz --output /tmp/glow.tgz --silent <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> tar zxf /tmp/glow.tgz <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> mv glow /usr/local/bin<span>
</span></span></span></code></pre></div><h2 id=vscode-devcontainers>VSCode DevContainers</h2><p>My main use case for this are <a href=https://code.visualstudio.com/docs/devcontainers/containers>VSCode DevContainers</a>. These allow users of VSCode or <a href=https://github.com/features/codespaces>GitHub Codespaces</a> to package their development environment along with the code in their repositories - resulting in predictable environments for all participants in a project. They are a very effective way of avoiding the &ldquo;Works on my machine&rdquo; syndrome - and are based on Docker.</p><p>As you open a project in its DevContainer for the first time, VSCode will kick off an initial Docker image build process. Currently, that does not involve any dynamic elements or <a href=https://containers.dev/implementors/json_reference/#variables-in-devcontainerjson>pre-defined environment variables</a> to use as architecture switches. As a result, we seem to be stuck with the second alternative: embedding commands.</p><p>Despite the additional maintenance issues, this has proven to work very well. Both my Intel-based colleagues and the Apple aficionados can now work inside identical development configurations.</p><p>For example, when writing new blog posts inside of their VSCode environment like I did with this post.</p></div></div></article><article class=uk-article><div class=container><section class=author-box itemprop=author itemscope itemtype=https://schema.org/Person><div class="media author-box"><div class=media-figure><img alt="Author Image" src=/authors/theinen.png class="avatar avatar-100 photo" height=125 width=125></div><div class=media-body><h2><a href=/authors/thomas-heinen>Thomas Heinen</a></h2><p>Thomas is a Cloud Consultant and Trainer at tecRacer Consulting with a focus on Chef, AWS, DevOps and Security.</p><div class=author-icons><a target=_self class=author-website title="Thomas Heinen's Author Profile" href=/authors/thomas-heinen data-original-title="Author's Profile"><i class="fas fa-id-card"></i></a>
<a target=_new class=author-xing title="Thomas Heinen on Xing" href=https://xing.com/profile/Thomas_Heinen4 data-original-title=Xing><i class="fab fa-xing"></i></a>
<a target=_new class=author-linkedin title="Thomas Heinen on LinkedIn" href=https://linkedin.com/in/thomas-heinen data-original-title=LinkdIn><i class="fab fa-linkedin"></i></a>
<a target=_new class=author-github title="Thomas Heinen on GitHub" href=https://github.com/tecracer-theinen data-original-title=Github><i class="fab fa-github"></i></a></div></div></div></section></div></article></main></div><div id=tm-footer class=tm-footer><div id=tm-footer class="tm-footer tm-footer-margin-top"><div class="uk-panel uk-panel-space uk-text-center"><p>Copyright © 2018-today by <a href=https://chef.tecracer.de/ target=_blank>tecRacer</a></p></div></div></div><div id=offcanvas class=uk-offcanvas aria-hidden=true><div class="uk-offcanvas-bar uk-offcanvas-bar-flip"><div class="uk-panel uk-text-center"><a href=https://tecracer-chef.github.io/></a>
<img src=https://tecracer-chef.github.io/img/logo/logo-tr.png alt></a></div><ul class="uk-nav uk-nav-offcanvas"><li><a href=/ title>Blog</a></li><li><a href=/authors title>Authors</a></li><li><a href=/github/github-prs.html title>Pull Requests</a></li></ul></div></div></div></body></html>